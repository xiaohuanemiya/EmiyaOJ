# EmiyaOJ 在线判题系统 详细设计文档

## 第5部分：安全设计、性能优化与部署架构

---

## 9. 安全设计详细实现

### 9.1 Spring Security框架集成

#### 9.1.1 SecurityConfig核心配置

```java
package com.emiyaoj.service.config;

import com.emiyaoj.common.handler.*;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

/**
 * Spring Security配置类
 * 负责系统安全框架的核心配置
 */
@Configuration
@RequiredArgsConstructor
@EnableWebSecurity          // 开启Spring Security自定义配置
@EnableMethodSecurity       // 开启方法级权限控制（@PreAuthorize）
public class SecurityConfig {
    
    // JWT认证过滤器
    private final JwtTokenOncePerRequestFilter jwtTokenFilter;
    
    // 认证用户无权限访问资源的处理器
    private final CustomerAccessDeniedHandler customerAccessDeniedHandler;
    
    // 匿名用户访问受限资源的处理器
    private final AnonymousAuthenticationHandler anonymousAuthentication;
    
    // 用户认证校验失败处理器
    private final LoginFailureHandler loginFailureHandler;
    
    /**
     * 密码加密器
     * 使用BCrypt算法进行密码加密
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    /**
     * 认证管理器
     * 用于执行认证操作
     */
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    /**
     * CORS跨域配置
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("*"));  // 允许所有来源
        configuration.setAllowedMethods(Arrays.asList(
            "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(false);
        configuration.setMaxAge(3600L);  // 预检请求缓存时间
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
    
    /**
     * 安全过滤器链配置
     * 核心配置方法，定义系统的安全策略
     */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        
        // 1. 配置CORS
        http.cors(configurer -> 
            configurer.configurationSource(corsConfigurationSource()));
        
        // 2. 配置异常处理
        http.exceptionHandling(configurer -> {
            configurer
                .accessDeniedHandler(customerAccessDeniedHandler)      // 授权失败处理
                .authenticationEntryPoint(anonymousAuthentication);     // 认证失败处理
        });
        
        // 3. 关闭CSRF（前后端分离项目不需要）
        http.csrf(AbstractHttpConfigurer::disable);
        
        // 4. 配置表单登录失败处理器
        http.formLogin(conf -> conf.failureHandler(loginFailureHandler));
        
        // 5. 配置会话管理策略为无状态（使用JWT，不依赖Session）
        http.sessionManagement(conf -> 
            conf.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        
        // 6. 配置URL授权规则
        http.authorizeHttpRequests(auth -> auth
            .requestMatchers(
                "/swagger-ui/**",       // Swagger文档
                "/swagger-ui.html",
                "/swagger-resources/**",
                "/v3/api-docs/**",
                "/webjars/**",
                "/doc.html",
                "/auth/login"           // 登录接口
            ).permitAll()               // 白名单路径，无需认证
            .anyRequest().authenticated()  // 其他所有请求需要认证
        );
        
        // 7. 添加JWT认证过滤器（在UsernamePasswordAuthenticationFilter之前执行）
        http.addFilterBefore(jwtTokenFilter, 
            UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
```

**配置要点说明**：

| 配置项 | 说明 | 作用 |
|--------|------|------|
| `@EnableMethodSecurity` | 启用方法级权限 | 支持`@PreAuthorize`注解进行细粒度权限控制 |
| `SessionCreationPolicy.STATELESS` | 无状态会话 | 不使用Session，完全依赖JWT Token |
| `csrf().disable()` | 关闭CSRF | 前后端分离项目不需要CSRF保护 |
| `addFilterBefore()` | 添加自定义过滤器 | JWT过滤器在标准认证过滤器之前执行 |

---

### 9.2 JWT认证过滤器详细设计

#### 9.2.1 JwtTokenOncePerRequestFilter实现

```java
package com.emiyaoj.service.config;

import com.alibaba.fastjson2.JSON;
import com.emiyaoj.common.constant.JwtClaimsConstant;
import com.emiyaoj.common.exception.CustomerAuthenticationException;
import com.emiyaoj.common.handler.LoginFailureHandler;
import com.emiyaoj.common.properties.JwtProperties;
import com.emiyaoj.common.utils.BaseContext;
import com.emiyaoj.common.utils.JwtUtil;
import com.emiyaoj.common.utils.RedisUtil;
import com.emiyaoj.service.domain.pojo.UserLogin;
import io.jsonwebtoken.Claims;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.util.ObjectUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

/**
 * JWT Token认证过滤器
 * 继承OncePerRequestFilter确保每个请求只执行一次
 */
@Component
@Slf4j
public class JwtTokenOncePerRequestFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtProperties jwtProperties;
    
    @Autowired
    private RedisUtil redisUtil;
    
    @Autowired
    private LoginFailureHandler loginFailureHandler;
    
    /**
     * 白名单路径（无需认证的路径）
     */
    private final String[] whitelist = {
        "/auth/login",
        "/swagger-ui/**",
        "/swagger-ui.html",
        "/swagger-resources/**",
        "/v3/api-docs/**",
        "/webjars/**",
        "/doc.html"
    };
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        // 1. OPTIONS请求直接放行（CORS预检请求）
        if ("OPTIONS".equalsIgnoreCase(request.getMethod())) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // 2. 判断当前请求是否在白名单中
        String uri = request.getRequestURI();
        if (isWhitelisted(uri)) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // 3. 执行Token校验
        try {
            this.validateToken(request);
        } catch (AuthenticationException e) {
            loginFailureHandler.onAuthenticationFailure(request, response, e);
            return;
        }
        
        // 4. 继续过滤器链
        filterChain.doFilter(request, response);
    }
    
    /**
     * 判断请求路径是否在白名单中
     */
    private boolean isWhitelisted(String uri) {
        for (String pattern : whitelist) {
            if (pattern.endsWith("/**")) {
                // 处理通配符路径
                String basePattern = pattern.substring(0, pattern.length() - 3);
                if (uri.startsWith(basePattern)) {
                    return true;
                }
            } else if (pattern.equals(uri)) {
                // 精确匹配
                return true;
            }
        }
        return false;
    }
    
    /**
     * 校验Token
     * 流程：提取Token → 解析Token → Redis校验 → 刷新有效期 → 设置SecurityContext
     */
    private void validateToken(HttpServletRequest request) {
        // 1. 从请求头或参数中提取Token
        String token = request.getHeader("Authorization");
        if (ObjectUtils.isEmpty(token)) {
            token = request.getParameter("Authorization");
        }
        
        // 2. Token为空或无效值，抛出异常
        if (ObjectUtils.isEmpty(token) || 
            token.equals("undefined") || 
            token.equals("null")) {
            throw new CustomerAuthenticationException("token为空");
        }
        
        // 3. 去掉Bearer前缀
        if (token.startsWith("Bearer ")) {
            token = token.substring(7);
        }
        
        // 4. 解析JWT Token
        UserLogin userLogin;
        try {
            log.info("JWT校验: {}", token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getSecretKey(), token);
            
            // 5. 从Claims中获取用户信息
            String loginUserString = claims.get(
                JwtClaimsConstant.USER_LOGIN).toString();
            userLogin = JSON.parseObject(loginUserString, UserLogin.class);
            
            // 6. Redis校验Token是否存在
            String redisKey = "token_" + userLogin.getUser().getId();
            if (!redisUtil.hasKey(redisKey)) {
                throw new CustomerAuthenticationException("token已过期");
            }
            
            // 7. Token有效，刷新过期时间（滑动过期机制）
            redisUtil.set(redisKey, token, jwtProperties.getTtl());
            
            log.info("当前用户ID: {}", userLogin.getUser().getId());
            BaseContext.setCurrentId(userLogin.getUser().getId());
            
        } catch (Exception ex) {
            log.error("Token校验失败", ex);
            throw new CustomerAuthenticationException("token校验失败");
        }
        
        // 8. 设置SecurityContext（将认证信息放入Spring Security上下文）
        UsernamePasswordAuthenticationToken authentication = 
            new UsernamePasswordAuthenticationToken(
                userLogin, 
                null, 
                userLogin.getAuthorities()  // 用户权限列表
            );
        SecurityContextHolder.getContext().setAuthentication(authentication);
        
        log.info("用户权限: {}", userLogin.getAuthorities());
    }
}
```

**Token校验流程图**：

```
┌─────────────────────────────────────────────────────────────────┐
│                    JWT Token校验流程                             │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                   ┌─────────────────────┐
                   │ 1. 从请求头提取Token │
                   └─────────────────────┘
                              │
                              ▼
                   ┌─────────────────────┐
                   │ 2. Token为空？      │──YES──→ 抛出异常
                   └─────────────────────┘
                              │ NO
                              ▼
                   ┌─────────────────────┐
                   │ 3. 解析JWT Token    │
                   │   - 验证签名        │
                   │   - 检查过期时间    │
                   └─────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    │ 解析成功           │ 解析失败
                    ▼                   ▼
         ┌─────────────────────┐  ┌──────────────┐
         │ 4. 从Claims获取用户 │  │ 抛出异常     │
         │    信息（JSON反序列化）│  └──────────────┘
         └─────────────────────┘
                    │
                    ▼
         ┌─────────────────────┐
         │ 5. Redis校验Token   │
         │    存在性            │
         └─────────────────────┘
                    │
         ┌──────────┴──────────┐
         │ 存在                │ 不存在
         ▼                     ▼
┌─────────────────────┐  ┌──────────────────┐
│ 6. 刷新Token过期时间 │  │ 抛出"token已过期" │
│   （滑动过期机制）    │  └──────────────────┘
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│ 7. 设置SecurityContext│
│   - Authentication   │
│   - Authorities      │
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│ 8. 继续过滤器链     │
└─────────────────────┘
```

---

### 9.3 JWT工具类详细设计

#### 9.3.1 JwtUtil核心方法

```java
package com.emiyaoj.common.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.Map;

/**
 * JWT令牌工具类
 * 基于jjwt 0.12.x版本
 */
public class JwtUtil {
    
    /**
     * 生成JWT Token
     * 使用HS256算法和固定密钥
     * 
     * @param secretKey JWT密钥（至少256位）
     * @param ttlMillis JWT过期时间（毫秒）
     * @param claims    载荷信息（用户信息等）
     * @return JWT Token字符串
     */
    public static String createJWT(String secretKey, long ttlMillis, 
                                   Map<String, Object> claims) {
        // 1. 计算过期时间
        long expMillis = System.currentTimeMillis() + ttlMillis;
        Date exp = new Date(expMillis);
        
        // 2. 创建密钥（HMAC-SHA256）
        SecretKey key = Keys.hmacShaKeyFor(
            secretKey.getBytes(StandardCharsets.UTF_8));
        
        // 3. 构建JWT
        JwtBuilder builder = Jwts.builder()
            .claims(claims)              // 设置载荷（必须在标准声明之前）
            .signWith(key)               // 设置签名算法和密钥
            .expiration(exp);            // 设置过期时间
        
        return builder.compact();
    }
    
    /**
     * 解析JWT Token
     * 
     * @param secretKey JWT密钥
     * @param token     JWT Token字符串
     * @return Claims载荷信息
     * @throws JwtException 如果Token无效或过期
     */
    public static Claims parseJWT(String secretKey, String token) {
        // 1. 创建密钥
        SecretKey key = Keys.hmacShaKeyFor(
            secretKey.getBytes(StandardCharsets.UTF_8));
        
        // 2. 解析Token
        return Jwts.parser()
            .verifyWith(key)             // 设置验证密钥
            .build()
            .parseSignedClaims(token)    // 解析并验证签名
            .getPayload();               // 获取载荷
    }
}
```

**JWT Token结构**：

```
Header（头部）:
{
  "alg": "HS256",           // 签名算法
  "typ": "JWT"              // Token类型
}

Payload（载荷）:
{
  "userLogin": {            // 自定义字段：用户登录信息
    "user": {
      "id": 123456,
      "username": "admin",
      "nickname": "管理员"
    },
    "authorities": [...]    // 用户权限列表
  },
  "exp": 1704672000         // 标准字段：过期时间
}

Signature（签名）:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secretKey
)
```

---

### 9.4 Redis缓存设计

#### 9.4.1 RedisConfig配置

```java
package com.emiyaoj.common.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * Redis配置类
 */
@Configuration
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(
            RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        
        // 使用StringRedisSerializer序列化Key和Value
        StringRedisSerializer serializer = new StringRedisSerializer();
        template.setKeySerializer(serializer);
        template.setValueSerializer(serializer);
        template.setHashKeySerializer(serializer);
        template.setHashValueSerializer(serializer);
        
        template.afterPropertiesSet();
        return template;
    }
}
```

#### 9.4.2 RedisUtil工具类

```java
package com.emiyaoj.common.utils;

import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.util.concurrent.TimeUnit;

/**
 * Redis工具类
 * 封装常用的Redis操作
 */
@Component
@RequiredArgsConstructor
public class RedisUtil {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 判断Key是否存在
     */
    public boolean hasKey(String key) {
        return Boolean.TRUE.equals(redisTemplate.hasKey(key));
    }
    
    /**
     * 设置键值
     */
    public void set(String key, Object value) {
        redisTemplate.opsForValue().set(key, value);
    }
    
    /**
     * 设置键值并指定过期时间（毫秒）
     */
    public void set(String key, Object value, long timeout) {
        this.setWithExpire(key, value, timeout, TimeUnit.MILLISECONDS);
    }
    
    /**
     * 设置键值并指定过期时间和时间单位
     */
    public void setWithExpire(String key, Object value, 
                              long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, timeout, unit);
    }
    
    /**
     * 获取键值
     */
    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }
    
    /**
     * 删除键
     */
    public void delete(String key) {
        redisTemplate.delete(key);
    }
}
```

#### 9.4.3 Redis缓存应用场景

| 应用场景 | Key格式 | Value类型 | 过期时间 | 说明 |
|---------|---------|----------|---------|------|
| JWT Token存储 | `token_{userId}` | String | 2小时 | 存储用户Token，实现单点登录 |
| 用户权限缓存 | `permissions_{userId}` | List | 30分钟 | 缓存用户权限列表，减少数据库查询 |
| 题目信息缓存 | `problem_{problemId}` | String(JSON) | 1小时 | 缓存热门题目信息 |
| 提交记录缓存 | `submission_{submissionId}` | String(JSON) | 10分钟 | 缓存判题结果 |
| 验证码 | `captcha_{sessionId}` | String | 5分钟 | 存储图形验证码 |

**Redis键命名规范**：
- 使用冒号`:`或下划线`_`分隔不同层级
- 格式：`模块_业务_标识`
- 示例：`token_123456`、`permissions_123456`

---

## 10. 性能优化设计

### 10.1 数据库性能优化

#### 10.1.1 索引设计策略

**索引设计原则**：
1. **主键索引**：所有表必须有主键（使用雪花算法生成）
2. **唯一索引**：用户名、邮箱等唯一字段建立唯一索引
3. **普通索引**：高频查询字段建立索引
4. **联合索引**：多字段组合查询建立联合索引
5. **覆盖索引**：查询字段全部在索引中，避免回表

**核心表索引清单**：

```sql
-- user表索引
PRIMARY KEY (id)
UNIQUE KEY uk_username (username)
UNIQUE KEY uk_email (email)
INDEX idx_status (status)
INDEX idx_create_time (create_time)

-- problem表索引
PRIMARY KEY (id)
INDEX idx_difficulty (difficulty)
INDEX idx_status (status)
INDEX idx_author_id (author_id)
INDEX idx_create_time (create_time)

-- submission表索引
PRIMARY KEY (id)
INDEX idx_problem_id (problem_id)
INDEX idx_user_id (user_id)
INDEX idx_language_id (language_id)
INDEX idx_status (status)
INDEX idx_create_time (create_time)

-- test_case表索引
PRIMARY KEY (id)
INDEX idx_problem_id (problem_id)
INDEX idx_is_sample (is_sample)
INDEX idx_sort_order (sort_order)
```

#### 10.1.2 SQL优化策略

| 优化策略 | 说明 | 示例 |
|---------|------|------|
| 避免SELECT * | 只查询需要的字段 | `SELECT id, title FROM problem` |
| 分页查询优化 | 使用MyBatis-Plus分页插件 | `Page<User> page = new Page<>(1, 10)` |
| 批量操作 | 使用批量插入代替循环单条插入 | `saveBatch(list)` |
| JOIN优化 | 小表驱动大表，合理使用索引 | 用户-角色关联查询 |
| IN查询限制 | IN条件不超过1000个 | 批量查询时分批处理 |

#### 10.1.3 连接池配置优化

```yaml
spring:
  datasource:
    type: com.zabatech.hikari.HikariDataSource
    hikari:
      minimum-idle: 5              # 最小空闲连接数
      maximum-pool-size: 20        # 最大连接池大小
      auto-commit: true            # 自动提交
      idle-timeout: 30000          # 空闲连接超时（30秒）
      pool-name: EmiyaOJ-HikariCP
      max-lifetime: 1800000        # 连接最大生命周期（30分钟）
      connection-timeout: 30000    # 连接超时（30秒）
      connection-test-query: SELECT 1
```

---

### 10.2 应用层性能优化

#### 10.2.1 异步处理设计

**判题异步处理**：

```java
@Service
public class SubmissionServiceImpl implements ISubmissionService {
    
    /**
     * 提交代码（同步方法）
     */
    @Override
    public Long submitCode(SubmitCodeDTO submitDTO) {
        // 1. 创建提交记录
        Submission submission = new Submission();
        submission.setStatus("Pending");
        submissionMapper.insert(submission);
        
        // 2. 异步执行判题
        judgeAsync(submission.getId(), problem, language, code);
        
        // 3. 立即返回提交ID
        return submission.getId();
    }
    
    /**
     * 异步判题方法
     * 使用@Async注解标记为异步方法
     */
    @Async
    public void judgeAsync(Long submissionId, Problem problem, 
                          Language language, String code) {
        // 更新状态为判题中
        updateSubmissionStatus(submissionId, "Judging");
        
        // 执行判题逻辑...
        // 1. 编译代码
        // 2. 执行测试用例
        // 3. 比对输出
        // 4. 保存结果
    }
}
```

**异步配置**：

```java
@Configuration
@EnableAsync  // 启用异步支持
public class AsyncConfig {
    
    @Bean
    public Executor judgeExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);         // 核心线程数
        executor.setMaxPoolSize(10);         // 最大线程数
        executor.setQueueCapacity(100);      // 队列容量
        executor.setThreadNamePrefix("judge-");
        executor.initialize();
        return executor;
    }
}
```

#### 10.2.2 缓存策略

**多级缓存架构**：

```
┌─────────────────────────────────────────────────────────┐
│                     应用层                               │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────┐       ┌─────────────┐                 │
│  │  L1缓存     │       │  L2缓存     │                 │
│  │  本地缓存    │──失效──→│  Redis缓存  │                 │
│  │  (Caffeine) │       │  (分布式)    │                 │
│  └─────────────┘       └─────────────┘                 │
│         │                      │                        │
│         │ 缓存未命中             │ 缓存未命中              │
│         └──────────────────────┴────────────┐          │
│                                             ▼          │
│                                    ┌─────────────┐     │
│                                    │   MySQL     │     │
│                                    │   数据库     │     │
│                                    └─────────────┘     │
└─────────────────────────────────────────────────────────┘
```

**缓存应用示例**：

```java
@Service
public class ProblemServiceImpl implements IProblemService {
    
    @Autowired
    private RedisUtil redisUtil;
    
    /**
     * 获取题目详情（带缓存）
     */
    public ProblemVO getProblemById(Long id) {
        // 1. 尝试从Redis获取
        String cacheKey = "problem_" + id;
        Object cached = redisUtil.get(cacheKey);
        
        if (cached != null) {
            return JSON.parseObject(cached.toString(), ProblemVO.class);
        }
        
        // 2. 缓存未命中，查询数据库
        Problem problem = problemMapper.selectById(id);
        ProblemVO vo = convertToVO(problem);
        
        // 3. 写入缓存（1小时过期）
        redisUtil.set(cacheKey, JSON.toJSONString(vo), 3600000);
        
        return vo;
    }
}
```

---

## 11. 部署架构设计

### 11.1 系统部署架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        部署架构图                                │
└─────────────────────────────────────────────────────────────────┘

                        ┌───────────────┐
                        │  用户浏览器    │
                        └───────────────┘
                                │
                                ▼
                    ┌──────────────────────┐
                    │   Nginx反向代理       │
                    │   - 负载均衡          │
                    │   - 静态资源服务      │
                    └──────────────────────┘
                                │
                ┌───────────────┴───────────────┐
                │                               │
                ▼                               ▼
    ┌─────────────────────┐       ┌─────────────────────┐
    │  前端静态资源        │       │  后端应用服务器      │
    │  Vue + Vite构建     │       │  Spring Boot 3.5.5  │
    │  - 静态HTML/JS/CSS  │       │  - oj-service.jar   │
    └─────────────────────┘       └─────────────────────┘
                                              │
                        ┌─────────────────────┼─────────────────────┐
                        │                     │                     │
                        ▼                     ▼                     ▼
              ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
              │   MySQL     │     │   Redis     │     │  go-judge   │
              │   8.0.44    │     │   缓存服务   │     │  判题沙箱    │
              └─────────────┘     └─────────────┘     └─────────────┘
```

### 11.2 部署环境要求

#### 11.2.1 服务器配置

| 组件 | 最低配置 | 推荐配置 | 说明 |
|------|---------|---------|------|
| CPU | 2核 | 4核+ | 判题任务需要多核支持 |
| 内存 | 4GB | 8GB+ | JVM+MySQL+Redis |
| 磁盘 | 50GB | 100GB+ | 代码文件、日志、数据库 |
| 网络 | 1Mbps | 10Mbps+ | 用户访问带宽 |

#### 11.2.2 软件环境

| 软件 | 版本 | 说明 |
|------|------|------|
| JDK | 21+ | 运行Spring Boot应用 |
| MySQL | 8.0+ | 数据库服务 |
| Redis | 6.0+ | 缓存服务 |
| Nginx | 1.20+ | 反向代理和静态资源服务 |
| Docker | 20.10+ | 容器化部署（可选） |

---

### 11.3 Docker部署方案

#### 11.3.1 Dockerfile

```dockerfile
# 后端应用Dockerfile
FROM openjdk:21-jdk-slim

WORKDIR /app

# 复制JAR包
COPY oj-service/target/oj-service.jar app.jar

# 暴露端口
EXPOSE 8080

# 启动应用
ENTRYPOINT ["java", "-jar", "app.jar", \
    "--spring.profiles.active=prod"]
```

#### 11.3.2 docker-compose.yml

```yaml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: emiyaoj-mysql
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: emiya-oj
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./database/emiya-oj_final.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - emiyaoj-network

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: emiyaoj-redis
    ports:
      - "6379:6379"
    networks:
      - emiyaoj-network

  # 后端应用
  backend:
    build: .
    container_name: emiyaoj-backend
    ports:
      - "8080:8080"
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/emiya-oj
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: rootpassword
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
    depends_on:
      - mysql
      - redis
    networks:
      - emiyaoj-network

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: emiyaoj-nginx
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./frontend/dist:/usr/share/nginx/html
    depends_on:
      - backend
    networks:
      - emiyaoj-network

volumes:
  mysql-data:

networks:
  emiyaoj-network:
    driver: bridge
```

---

### 11.4 Nginx配置

```nginx
# nginx.conf
user nginx;
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;

    sendfile on;
    tcp_nopush on;
    keepalive_timeout 65;
    gzip on;

    # 后端服务器地址
    upstream backend {
        server backend:8080;
    }

    server {
        listen 80;
        server_name localhost;

        # 前端静态资源
        location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri $uri/ /index.html;
        }

        # 后端API代理
        location /api/ {
            proxy_pass http://backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # CORS配置
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods 'GET, POST, PUT, DELETE, OPTIONS';
            add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
        }

        # API文档
        location /swagger-ui/ {
            proxy_pass http://backend/swagger-ui/;
        }

        location /v3/api-docs {
            proxy_pass http://backend/v3/api-docs;
        }
    }
}
```

---

## 第5部分总结

本部分完成了以下内容的详细设计：

1. **安全设计**：
   - Spring Security完整配置（SecurityConfig）
   - JWT认证过滤器实现（JwtTokenOncePerRequestFilter）
   - JWT工具类设计（JwtUtil）
   - Token校验流程详解

2. **Redis缓存设计**：
   - RedisConfig配置
   - RedisUtil工具类
   - 缓存应用场景与键命名规范

3. **性能优化**：
   - 数据库索引设计策略
   - SQL优化策略
   - 连接池配置优化
   - 异步处理设计
   - 多级缓存架构

4. **部署架构**：
   - 系统部署架构图
   - 服务器配置要求
   - Docker部署方案（Dockerfile + docker-compose.yml）
   - Nginx反向代理配置

---

## 全文总结

EmiyaOJ详细设计文档共5个部分，涵盖了系统的所有核心设计：

- **第1部分**：总体设计、技术选型、核心组件
- **第2部分**：用户管理模块（User、RBAC）
- **第3部分**：在线判题模块（Problem、Submission、GoJudge）
- **第4部分**：博客模块、角色权限模块、系统管理
- **第5部分**：安全设计、性能优化、部署架构

文档完整覆盖了从数据库设计、后端架构、安全认证到部署运维的所有技术细节，为项目的开发、测试和部署提供了完整的技术指导。

---

*EmiyaOJ详细设计文档 - 第5部分（全文完）*
