# EmiyaOJ 在线判题系统 实验总结

## 文档信息

| 项目名称 | EmiyaOJ 在线判题系统 |
|----------|---------------------|
| 文档版本 | V1.0 |
| 完成日期 | 2026年1月7日 |
| 文档类型 | 实验总结报告 |
| 项目仓库 | xiaohuanemiya/EmiyaOJ |

---

## 1. 项目概述

### 1.1 项目背景与目标

EmiyaOJ是一个基于Spring Boot 3.5.5的在线判题系统（Online Judge），采用前后端分离架构，旨在提供完善的编程学习与竞赛平台。系统集成go-judge判题引擎，实现了代码的安全、准确、高效的自动评测。

**核心目标**：
- 提供安全可靠的代码自动判题功能
- 实现完善的题库管理与测试用例管理
- 构建基于RBAC的用户权限体系
- 提供博客社区功能促进技术交流
- 确保系统的高性能与可扩展性

### 1.2 技术选型

#### 后端技术栈

| 技术 | 版本 | 应用场景 |
|------|------|----------|
| Java | 21 | 开发语言，利用最新特性提升性能 |
| Spring Boot | 3.5.5 | 核心框架，简化配置与开发 |
| Spring Security | 6.x | 安全认证与权限控制 |
| MyBatis-Plus | 3.5.13 | ORM框架，提供代码生成器 |
| MySQL | 8.0.44 | 关系型数据库，持久化存储 |
| Redis | - | 缓存中间件，存储Token与权限 |
| jjwt | 0.12.6 | JWT令牌生成与解析 |
| go-judge | - | 代码判题沙箱引擎 |
| SpringDoc OpenAPI | 2.8.9 | API文档自动生成 |

#### 前端技术栈

| 技术 | 版本 | 应用场景 |
|------|------|----------|
| Vue | 3.5 | 前端MVVM框架 |
| Vite | 5.x | 构建工具，快速热更新 |
| TypeScript | 5.x | 类型安全的开发语言 |
| Element Plus | - | UI组件库 |
| Pinia | - | 状态管理 |
| Monaco Editor | - | 代码编辑器组件 |

### 1.3 项目架构

系统采用Maven多模块结构，分为两个核心模块：

```
EmiyaOJ/
├── oj-common/                 # 公共模块
│   ├── config/                # 通用配置（Redis、Knife4j）
│   ├── constant/              # 系统常量
│   ├── domain/                # 通用领域对象
│   ├── exception/             # 自定义异常
│   ├── handler/               # 全局处理器
│   ├── properties/            # 配置属性
│   └── utils/                 # 工具类（JWT、Redis、BaseContext）
│
└── oj-service/                # 服务模块
    ├── controller/            # 控制器层
    │   └── client/            # 客户端API
    ├── domain/                # 领域对象
    │   ├── dto/               # 数据传输对象
    │   ├── enums/             # 枚举类
    │   ├── pojo/              # 实体类
    │   └── vo/                # 视图对象
    ├── mapper/                # 数据访问层
    ├── service/               # 业务逻辑层
    │   └── impl/              # 服务实现
    └── util/oj/               # 判题引擎工具
```

---

## 2. 系统核心功能实现

### 2.1 用户管理模块

#### 2.1.1 RBAC权限模型设计

系统实现了完整的RBAC（基于角色的访问控制）权限模型：

**数据模型关系**：
```
用户(User) ─N:M→ 用户角色(user_role) ─N:1→ 角色(Role)
                                                │
                                                N:M
                                                │
                                      角色权限(role_permission)
                                                │
                                                N:1
                                                ▼
                                          权限(Permission)
```

**核心实体表**：

| 表名 | 说明 | 关键字段 |
|------|------|----------|
| user | 用户表 | id, username, password, email, status |
| role | 角色表 | id, role_code, role_name |
| permission | 权限表 | id, permission_code, permission_type |
| user_role | 用户角色关联表 | user_id, role_id |
| role_permission | 角色权限关联表 | role_id, permission_id |

#### 2.1.2 权限控制实现

**1. 权限类型分类**：
- **菜单权限**（type=1）：控制页面访问
- **按钮权限**（type=2）：控制操作按钮显示
- **接口权限**（type=3）：控制API调用

**2. 权限验证方式**：
- 使用Spring Security的`@PreAuthorize`注解
- 自定义权限表达式：`hasPermission('permission_code')`
- 在Service层查询用户权限列表并缓存至Redis

**3. 权限查询优化**：
```java
// 查询用户权限并缓存
List<String> permissions = userMapper.selectUserPermissions(userId);
redisUtil.set("permissions_" + userId, permissions, 30, TimeUnit.MINUTES);
```

#### 2.1.3 用户认证流程

**JWT认证机制**：

```
1. 用户登录 → 验证用户名密码
2. 生成JWT Token → 包含用户信息、角色、过期时间
3. 存储Token到Redis → 设置2小时过期时间
4. 返回Token给客户端 → 客户端存储到LocalStorage
5. 后续请求携带Token → 通过JwtTokenOncePerRequestFilter验证
6. 滑动过期机制 → 每次请求刷新Token过期时间
```

**Token结构设计**：
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "userLogin": {
      "userId": 1,
      "username": "admin",
      "roles": ["ADMIN"],
      "permissions": ["user:list", "role:add"]
    },
    "exp": 1704672000
  },
  "signature": "HMACSHA256(...)"
}
```

### 2.2 在线判题模块

#### 2.2.1 题目管理

**题目数据结构**：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 题目ID |
| title | varchar(255) | 题目标题 |
| description | text | 题目描述（支持Markdown） |
| difficulty | tinyint | 难度：1-简单，2-中等，3-困难 |
| time_limit | int | CPU时间限制（毫秒） |
| memory_limit | int | 内存限制（MB） |
| accept_count | int | 通过次数 |
| submit_count | int | 提交次数 |

**功能特性**：
- 支持Markdown格式的题目描述
- 题目难度分级管理
- 题目状态控制（公开/隐藏）
- 自动统计通过率和提交量

#### 2.2.2 测试用例管理

**测试用例设计**：

```sql
CREATE TABLE `test_case` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `problem_id` bigint NOT NULL COMMENT '题目ID',
  `input` longtext NOT NULL COMMENT '输入数据',
  `output` longtext NOT NULL COMMENT '预期输出',
  `is_sample` tinyint DEFAULT 0 COMMENT '是否为样例',
  `score` int DEFAULT 0 COMMENT '分值',
  `sort_order` int DEFAULT 0 COMMENT '排序',
  PRIMARY KEY (`id`),
  INDEX `idx_problem_id` (`problem_id`)
);
```

**测试用例特性**：
- 支持样例数据（is_sample=1）公开展示
- 支持部分分评测（通过score字段）
- 按sort_order排序执行

#### 2.2.3 判题引擎集成

**go-judge沙箱集成**：

系统集成了go-judge作为代码执行沙箱，确保代码在安全隔离环境中运行。

**判题流程**：
```
1. 接收代码提交 → 创建submission记录（状态：Pending）
2. 获取题目信息 → 读取时间限制、内存限制
3. 获取测试用例 → 按顺序加载所有test_case
4. 编译代码（如需要） → 检查编译错误
5. 逐个执行测试用例 → 在go-judge沙箱中运行
6. 比对输出结果 → 判断Accept、Wrong Answer等
7. 记录判题结果 → 更新submission状态和结果
8. 更新题目统计 → 增加提交次数/通过次数
```

**支持的编程语言**：

| 语言 | 版本 | 编译命令 | 执行命令 |
|------|------|----------|----------|
| C | gcc-11 | `gcc -o {exe} {src} -O2 -std=c11 -lm` | `./{exe}` |
| C++ | g++-11 | `g++ -o {exe} {src} -O2 -std=c++17` | `./{exe}` |

#### 2.2.4 判题状态与结果

**判题状态枚举**：

| 状态 | 说明 |
|------|------|
| Pending | 等待判题 |
| Judging | 判题中 |
| Accepted | 通过 |
| Wrong Answer | 答案错误 |
| Time Limit Exceeded | 超时 |
| Memory Limit Exceeded | 内存超限 |
| Runtime Error | 运行时错误 |
| Compile Error | 编译错误 |
| System Error | 系统错误 |

**判题结果存储**：

```sql
-- 提交记录表
CREATE TABLE `submission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `problem_id` bigint NOT NULL,
  `user_id` bigint NOT NULL,
  `language_id` bigint NOT NULL,
  `code` longtext NOT NULL,
  `status` varchar(50) NOT NULL,
  `score` int DEFAULT 0,
  `time_used` int DEFAULT 0,
  `memory_used` int DEFAULT 0,
  `pass_rate` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
);

-- 测试用例结果表
CREATE TABLE `submission_result` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `submission_id` bigint NOT NULL,
  `test_case_id` bigint NOT NULL,
  `status` varchar(50) NOT NULL,
  `time_used` int DEFAULT 0,
  `memory_used` int DEFAULT 0,
  PRIMARY KEY (`id`)
);
```

### 2.3 博客模块

#### 2.3.1 博客功能设计

**核心功能**：
- 博客发布与编辑（支持Markdown）
- 博客评论系统
- 博客收藏功能
- 博客标签分类
- 用户博客统计

**数据表结构**：

| 表名 | 说明 | 关键功能 |
|------|------|----------|
| blog | 博客主表 | 存储博客标题、内容 |
| blog_comment | 评论表 | 存储博客评论 |
| blog_star | 收藏表 | 用户收藏博客关联 |
| blog_tag | 标签表 | 博客标签定义 |
| blog_tag_association | 标签关联表 | 博客-标签多对多关联 |
| user_blog | 用户博客统计表 | 统计博客数量、收藏数量 |

#### 2.3.2 数据库触发器设计

为了自动维护用户博客统计数据，系统使用MySQL触发器：

**触发器列表**：

```sql
-- 1. 博客发布后增加blog_count
CREATE TRIGGER `after_blog_insert` AFTER INSERT ON `blog`
FOR EACH ROW BEGIN
    UPDATE user_blog
    SET blog_count = blog_count + 1
    WHERE user_id = NEW.user_id;
END;

-- 2. 博客删除后减少blog_count
CREATE TRIGGER `after_blog_delete` AFTER UPDATE ON `blog`
FOR EACH ROW BEGIN
    IF NEW.deleted = 1 AND OLD.deleted = 0 THEN
        UPDATE user_blog
        SET blog_count = blog_count - 1
        WHERE user_id = NEW.user_id;
    END IF;
END;

-- 3. 收藏博客后增加star_count
CREATE TRIGGER `after_blog_star_insert` AFTER INSERT ON `blog_star`
FOR EACH ROW BEGIN
    UPDATE user_blog
    SET star_count = star_count + 1
    WHERE user_id = NEW.user_id;
END;

-- 4. 取消收藏后减少star_count
CREATE TRIGGER `after_blog_star_delete` AFTER DELETE ON `blog_star`
FOR EACH ROW BEGIN
    UPDATE user_blog
    SET star_count = star_count - 1
    WHERE user_id = OLD.user_id;
END;
```

**设计优势**：
- 数据一致性由数据库保证
- 减少应用层代码复杂度
- 自动同步统计数据

### 2.4 系统管理模块

#### 2.4.1 操作日志

**日志记录内容**：

| 字段 | 说明 |
|------|------|
| oper_user_id | 操作用户ID |
| oper_username | 操作用户名 |
| oper_module | 操作模块 |
| oper_type | 操作类型（INSERT/UPDATE/DELETE） |
| oper_method | 操作方法（类名.方法名） |
| oper_params | 操作参数（JSON格式） |
| oper_result | 操作结果（SUCCESS/FAIL） |
| oper_time | 操作时间 |
| ip_address | 操作IP地址 |

**日志记录方式**：
- 使用AOP切面自动记录
- 异步记录，不影响业务性能
- 敏感信息脱敏处理

---

## 3. 安全设计实现

### 3.1 Spring Security配置

#### 3.1.1 核心配置

```java
@Configuration
@EnableWebSecurity          // 开启Spring Security
@EnableMethodSecurity       // 开启方法级权限控制
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) {
        return http
            .csrf(AbstractHttpConfigurer::disable)  // 关闭CSRF
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/user/login", "/client/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
            .build();
    }
}
```

**配置要点**：
- 无状态会话管理（不使用Session）
- JWT过滤器前置执行
- 公开接口白名单配置

#### 3.1.2 密码加密

使用BCrypt加密算法：

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// 密码加密
String encodedPassword = passwordEncoder.encode(rawPassword);

// 密码验证
boolean matches = passwordEncoder.matches(rawPassword, encodedPassword);
```

**BCrypt优势**：
- 自动加盐（Salt）
- 慢速哈希（防暴力破解）
- 不可逆加密

### 3.2 JWT Token管理

#### 3.2.1 Token生成

```java
public String createToken(Map<String, Object> claims) {
    SecretKey key = Keys.hmacShaKeyFor(
        secretKey.getBytes(StandardCharsets.UTF_8)
    );
    
    return Jwts.builder()
        .claims(claims)
        .expiration(new Date(System.currentTimeMillis() + ttl))
        .signWith(key, Jwts.SIG.HS256)
        .compact();
}
```

#### 3.2.2 Token验证过滤器

**JwtTokenOncePerRequestFilter**流程：

```
1. 从请求头获取Token（Authorization: Bearer {token}）
2. 解析Token获取用户信息
3. 从Redis验证Token有效性
4. 检查Token是否过期
5. 刷新Token过期时间（滑动过期）
6. 设置SecurityContext认证信息
7. 继续过滤器链执行
```

**滑动过期机制**：
```java
// 每次请求刷新Token在Redis中的过期时间
redisUtil.expire("token_" + userId, 2, TimeUnit.HOURS);
```

### 3.3 Redis缓存设计

#### 3.3.1 缓存应用场景

| 应用场景 | Key格式 | Value类型 | 过期时间 |
|---------|---------|----------|---------|
| JWT Token | `token_{userId}` | String | 2小时 |
| 用户权限 | `permissions_{userId}` | List | 30分钟 |
| 题目信息 | `problem_{problemId}` | JSON | 1小时 |
| 提交结果 | `submission_{id}` | JSON | 10分钟 |

#### 3.3.2 缓存工具类

```java
@Component
public class RedisUtil {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    // 设置键值对
    public void set(String key, Object value, long timeout, TimeUnit unit) {
        redisTemplate.opsForValue().set(key, value, timeout, unit);
    }
    
    // 获取值
    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }
    
    // 删除键
    public void delete(String key) {
        redisTemplate.delete(key);
    }
    
    // 刷新过期时间
    public void expire(String key, long timeout, TimeUnit unit) {
        redisTemplate.expire(key, timeout, unit);
    }
}
```

### 3.4 代码沙箱隔离

**go-judge沙箱安全机制**：

1. **资源限制**：
   - CPU时间限制
   - 内存使用限制
   - 栈内存限制
   - 进程数量限制

2. **系统调用过滤**：
   - 白名单模式：只允许必要的系统调用
   - 禁止文件操作、网络访问等危险操作

3. **进程隔离**：
   - 使用namespace隔离
   - 限制进程权限
   - 独立的文件系统视图

---

## 4. 性能优化措施

### 4.1 数据库优化

#### 4.1.1 索引设计

**核心表索引策略**：

```sql
-- user表索引
PRIMARY KEY (id)
UNIQUE KEY uk_username (username)
UNIQUE KEY uk_email (email)
INDEX idx_status (status)
INDEX idx_create_time (create_time)

-- problem表索引
PRIMARY KEY (id)
INDEX idx_difficulty (difficulty)
INDEX idx_status (status)
INDEX idx_author_id (author_id)

-- submission表索引
PRIMARY KEY (id)
INDEX idx_problem_id (problem_id)
INDEX idx_user_id (user_id)
INDEX idx_status (status)
INDEX idx_create_time (create_time)
```

**索引设计原则**：
- 主键索引：所有表必须有主键
- 唯一索引：用户名、邮箱等唯一字段
- 普通索引：高频查询字段
- 联合索引：多字段组合查询

#### 4.1.2 查询优化

**MyBatis-Plus分页查询**：

```java
// 使用MyBatis-Plus分页插件
Page<Problem> page = new Page<>(pageNum, pageSize);
Page<Problem> result = problemMapper.selectPage(page, queryWrapper);
```

**SQL优化技巧**：
- 避免SELECT *，只查询需要的字段
- 使用LIMIT限制返回数据量
- 合理使用JOIN，避免N+1查询
- 使用EXPLAIN分析SQL执行计划

### 4.2 缓存优化

#### 4.2.1 多级缓存策略

```
1. Redis缓存：热点数据缓存
2. 本地缓存：频繁访问的配置数据
3. CDN缓存：静态资源缓存
```

#### 4.2.2 缓存失效策略

**缓存更新策略**：
- **Cache Aside模式**：先更新数据库，再删除缓存
- **定时刷新**：定时任务刷新热点数据
- **主动失效**：数据修改时主动清除相关缓存

**缓存雪崩防护**：
- 设置随机过期时间：`ttl + random(0, 300)`
- 使用互斥锁防止缓存击穿

### 4.3 异步处理

#### 4.3.1 判题异步化

**异步判题设计**：

```java
// 提交代码后立即返回
@PostMapping("/submit")
public Result<Long> submitCode(@RequestBody SubmitDTO submitDTO) {
    // 1. 创建提交记录（状态：Pending）
    Submission submission = new Submission();
    submission.setStatus("Pending");
    submissionService.save(submission);
    
    // 2. 异步执行判题任务
    CompletableFuture.runAsync(() -> {
        judgeService.judge(submission.getId());
    }, executorService);
    
    // 3. 立即返回提交ID
    return Result.success(submission.getId());
}

// 客户端轮询获取结果
@GetMapping("/submission/{id}")
public Result<SubmissionVO> getSubmission(@PathVariable Long id) {
    return Result.success(submissionService.getById(id));
}
```

**优势**：
- 避免长时间阻塞用户请求
- 提高系统并发处理能力
- 判题失败不影响用户体验

#### 4.3.2 线程池配置

```java
@Configuration
public class ExecutorConfig {
    
    @Bean
    public ThreadPoolExecutor judgeExecutor() {
        return new ThreadPoolExecutor(
            10,                      // 核心线程数
            20,                      // 最大线程数
            60L,                     // 空闲线程存活时间
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(100)  // 任务队列
        );
    }
}
```

---

## 5. API设计规范

### 5.1 RESTful API设计

#### 5.1.1 URL命名规范

| 操作 | HTTP方法 | URL | 说明 |
|------|---------|-----|------|
| 查询列表 | GET | `/problems` | 分页查询题目列表 |
| 查询详情 | GET | `/problems/{id}` | 获取单个题目详情 |
| 创建资源 | POST | `/problems` | 创建新题目 |
| 更新资源 | PUT | `/problems/{id}` | 完整更新题目 |
| 部分更新 | PATCH | `/problems/{id}` | 部分更新题目 |
| 删除资源 | DELETE | `/problems/{id}` | 删除题目 |

#### 5.1.2 统一响应格式

```java
@Data
public class Result<T> {
    private Integer code;        // 状态码
    private String message;      // 提示信息
    private T data;              // 响应数据
    
    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("操作成功");
        result.setData(data);
        return result;
    }
    
    public static <T> Result<T> error(String message) {
        Result<T> result = new Result<>();
        result.setCode(500);
        result.setMessage(message);
        return result;
    }
}
```

**响应示例**：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "id": 1,
    "title": "两数之和",
    "difficulty": 1
  }
}
```

### 5.2 异常处理

#### 5.2.1 全局异常处理器

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public Result<?> handleBusinessException(BusinessException e) {
        return Result.error(e.getMessage());
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidationException(
            MethodArgumentNotValidException e) {
        String message = e.getBindingResult()
                          .getAllErrors()
                          .get(0)
                          .getDefaultMessage();
        return Result.error(message);
    }
    
    @ExceptionHandler(Exception.class)
    public Result<?> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error("系统异常，请联系管理员");
    }
}
```

#### 5.2.2 自定义业务异常

```java
public class BusinessException extends RuntimeException {
    private Integer code;
    
    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }
    
    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }
}

// 使用示例
if (user == null) {
    throw new BusinessException("用户不存在");
}
```

### 5.3 参数校验

#### 5.3.1 DTO参数校验

```java
@Data
public class UserSaveDTO {
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
}
```

#### 5.3.2 Controller层校验

```java
@PostMapping
public Result<Void> save(@RequestBody @Valid UserSaveDTO dto) {
    userService.save(dto);
    return Result.success();
}
```

---

## 6. 项目亮点与创新

### 6.1 技术亮点

#### 6.1.1 安全沙箱隔离

- **go-judge集成**：使用成熟的判题沙箱引擎，确保代码执行安全
- **资源限制**：精确控制CPU时间、内存、栈空间等资源
- **系统调用过滤**：白名单模式阻止危险操作

#### 6.1.2 完善的权限体系

- **RBAC模型**：用户-角色-权限三层架构，灵活配置
- **细粒度控制**：支持菜单权限、按钮权限、接口权限
- **权限缓存**：Redis缓存权限列表，提高验证效率

#### 6.1.3 JWT无状态认证

- **无Session依赖**：完全无状态，易于水平扩展
- **滑动过期**：每次请求自动刷新过期时间
- **单点登录**：同一用户只能保持一个有效Token

#### 6.1.4 异步判题机制

- **非阻塞提交**：提交后立即返回，不阻塞用户
- **线程池管理**：合理配置线程池，控制并发判题数量
- **状态轮询**：客户端轮询获取判题结果

### 6.2 设计亮点

#### 6.2.1 模块化架构

- **Maven多模块**：oj-common、oj-service分离，职责清晰
- **分层设计**：Controller-Service-Mapper三层架构
- **依赖管理**：父工程统一版本管理，避免依赖冲突

#### 6.2.2 数据库触发器应用

- **自动统计**：博客数量、收藏数量由触发器自动维护
- **数据一致性**：数据库层面保证统计数据准确性
- **减少代码量**：无需在应用层编写统计逻辑

#### 6.2.3 API文档自动生成

- **SpringDoc集成**：自动生成OpenAPI 3.0规范文档
- **Knife4j增强**：提供更美观的API文档界面
- **注解驱动**：通过注解描述API功能和参数

### 6.3 性能优化亮点

#### 6.3.1 多级缓存

- **Redis缓存**：热点数据缓存，减少数据库压力
- **权限缓存**：用户权限缓存30分钟，避免频繁查询
- **题目缓存**：热门题目缓存1小时

#### 6.3.2 数据库优化

- **索引优化**：核心查询字段建立索引
- **分页查询**：使用MyBatis-Plus分页插件
- **查询优化**：避免N+1查询，合理使用JOIN

#### 6.3.3 异步处理

- **判题异步化**：避免长时间阻塞
- **日志异步化**：操作日志异步记录
- **事件驱动**：使用Spring Event解耦业务

---

## 7. 开发流程与方法

### 7.1 开发流程

```
需求分析 → 概要设计 → 详细设计 → 编码实现 → 单元测试 → 集成测试 → 部署上线
```

#### 7.1.1 需求分析

- 明确系统核心功能：用户管理、判题、博客
- 确定技术选型：Spring Boot 3.x + Vue 3.x
- 制定开发计划：模块优先级排期

#### 7.1.2 设计阶段

**概要设计**：
- 系统架构设计
- 模块划分
- 技术选型
- 接口规范

**详细设计**：
- 数据表设计（ER图）
- 类图设计
- 接口详细设计
- 安全设计

#### 7.1.3 编码实现

**代码规范**：
- 遵循阿里巴巴Java开发手册
- 使用Lombok简化代码
- 统一命名规范
- 添加必要注释

**版本控制**：
- Git分支管理：master、develop、feature
- 提交信息规范：feat、fix、docs、refactor

#### 7.1.4 测试阶段

**单元测试**：
- Service层单元测试
- 使用JUnit 5 + Mockito
- 测试覆盖率要求：核心业务>80%

**集成测试**：
- API接口测试（Postman）
- 判题功能测试
- 权限验证测试

### 7.2 开发工具

| 工具 | 用途 |
|------|------|
| IntelliJ IDEA | Java开发IDE |
| WebStorm / VS Code | 前端开发IDE |
| Navicat | 数据库管理工具 |
| Postman | API测试工具 |
| Git | 版本控制工具 |
| Maven | 项目构建工具 |
| Docker | 容器化部署 |

### 7.3 项目管理

- **代码仓库**：GitHub - xiaohuanemiya/EmiyaOJ
- **问题追踪**：GitHub Issues
- **文档管理**：Markdown格式文档
- **API文档**：Knife4j自动生成

---

## 8. 遇到的问题与解决

### 8.1 技术难点

#### 8.1.1 判题沙箱集成

**问题描述**：
- go-judge沙箱的API调用复杂
- 需要精确控制资源限制
- 不同编程语言需要不同的编译和执行命令

**解决方案**：
```java
// 封装go-judge客户端
public class GoJudgeClient {
    
    public JudgeResult judge(JudgeRequest request) {
        // 1. 构建go-judge请求参数
        Map<String, Object> params = buildParams(request);
        
        // 2. 调用go-judge API
        String result = httpClient.post(JUDGE_URL, params);
        
        // 3. 解析判题结果
        return parseResult(result);
    }
    
    private Map<String, Object> buildParams(JudgeRequest request) {
        Map<String, Object> params = new HashMap<>();
        params.put("language", request.getLanguage());
        params.put("code", request.getCode());
        params.put("timeLimit", request.getTimeLimit());
        params.put("memoryLimit", request.getMemoryLimit());
        params.put("testCases", request.getTestCases());
        return params;
    }
}
```

**经验总结**：
- 阅读go-judge官方文档，理解沙箱原理
- 封装统一的判题接口，隐藏底层实现
- 提供不同语言的配置模板

#### 8.1.2 权限控制实现

**问题描述**：
- RBAC模型的数据库设计复杂
- 权限验证逻辑分散在多处
- 需要支持动态权限配置

**解决方案**：
```java
// 1. 数据库设计：用户-角色-权限三层关联
// 2. 权限查询：自定义SQL联表查询
@Select("SELECT DISTINCT p.permission_code " +
        "FROM permission p " +
        "JOIN role_permission rp ON p.id = rp.permission_id " +
        "JOIN user_role ur ON rp.role_id = ur.role_id " +
        "WHERE ur.user_id = #{userId} AND p.status = 1")
List<String> selectUserPermissions(@Param("userId") Long userId);

// 3. 权限验证：使用Spring Security注解
@PreAuthorize("hasAuthority('problem:add')")
@PostMapping
public Result<Void> addProblem(@RequestBody ProblemDTO dto) {
    problemService.save(dto);
    return Result.success();
}

// 4. 权限缓存：Redis缓存用户权限
List<String> permissions = permissionMapper.selectUserPermissions(userId);
redisUtil.set("permissions_" + userId, permissions, 30, TimeUnit.MINUTES);
```

**经验总结**：
- RBAC模型是经典的权限控制方案
- 使用Spring Security简化权限验证
- 缓存权限列表提高性能

#### 8.1.3 JWT Token管理

**问题描述**：
- Token失效后用户体验不佳
- 需要实现Token自动刷新
- 多设备登录问题

**解决方案**：
```java
// 滑动过期机制
public void refreshTokenExpiration(String token) {
    Claims claims = JwtUtil.parseToken(token);
    Long userId = claims.get("userId", Long.class);
    
    // 刷新Redis中Token的过期时间
    redisUtil.expire("token_" + userId, 2, TimeUnit.HOURS);
}

// 单点登录：同一用户只保留最新Token
public String login(String username, String password) {
    // 1. 验证用户名密码
    User user = userService.getByUsername(username);
    if (!passwordEncoder.matches(password, user.getPassword())) {
        throw new BusinessException("密码错误");
    }
    
    // 2. 删除旧Token
    redisUtil.delete("token_" + user.getId());
    
    // 3. 生成新Token
    String token = JwtUtil.createToken(user);
    redisUtil.set("token_" + user.getId(), token, 2, TimeUnit.HOURS);
    
    return token;
}
```

**经验总结**：
- 滑动过期提升用户体验
- Redis存储Token实现单点登录
- Token刷新策略需要权衡安全性和用户体验

### 8.2 性能问题

#### 8.2.1 数据库查询慢

**问题描述**：
- 题目列表查询慢（未建立索引）
- 用户权限查询慢（多次联表查询）

**解决方案**：
```sql
-- 1. 添加索引
CREATE INDEX idx_difficulty ON problem(difficulty);
CREATE INDEX idx_status ON problem(status);

-- 2. 优化SQL（减少联表）
-- 原SQL：3次JOIN
SELECT * FROM user u
JOIN user_role ur ON u.id = ur.user_id
JOIN role r ON ur.role_id = r.id
JOIN role_permission rp ON r.id = rp.role_id
JOIN permission p ON rp.permission_id = p.id;

-- 优化后：缓存权限列表
List<String> permissions = redisUtil.get("permissions_" + userId);
if (permissions == null) {
    permissions = permissionMapper.selectUserPermissions(userId);
    redisUtil.set("permissions_" + userId, permissions, 30, TimeUnit.MINUTES);
}
```

#### 8.2.2 判题并发问题

**问题描述**：
- 大量提交导致系统卡顿
- go-judge沙箱资源耗尽

**解决方案**：
```java
// 1. 使用线程池控制并发数
@Configuration
public class ExecutorConfig {
    @Bean
    public ThreadPoolExecutor judgeExecutor() {
        return new ThreadPoolExecutor(
            10,     // 核心线程数
            20,     // 最大线程数
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(100)  // 任务队列
        );
    }
}

// 2. 异步判题
@Async("judgeExecutor")
public void judgeAsync(Long submissionId) {
    // 判题逻辑
}
```

### 8.3 部署问题

#### 8.3.1 跨域问题

**问题描述**：
- 前端请求后端API出现跨域错误

**解决方案**：
```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:5173")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

#### 8.3.2 MySQL连接问题

**问题描述**：
- MySQL 8.0连接报时区错误

**解决方案**：
```yaml
# application.yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/emiya_oj?serverTimezone=Asia/Shanghai&useSSL=false
```

---

## 9. 项目总结与展望

### 9.1 项目收获

#### 9.1.1 技术能力提升

**后端开发**：
- 掌握Spring Boot 3.x全家桶使用
- 理解Spring Security安全框架原理
- 熟练使用MyBatis-Plus进行数据访问
- 掌握JWT无状态认证机制
- 学会Redis缓存设计与应用

**系统设计**：
- 理解RBAC权限模型设计
- 掌握RESTful API设计规范
- 学会使用分层架构组织代码
- 理解异步处理机制

**性能优化**：
- 数据库索引设计与SQL优化
- Redis缓存策略应用
- 异步任务与线程池管理

#### 9.1.2 项目管理能力

- Git版本控制与分支管理
- 文档驱动开发（需求-设计-实现）
- 问题追踪与解决流程
- 代码规范与团队协作

#### 9.1.3 问题解决能力

- 学会分析和定位系统性能瓶颈
- 掌握常见安全问题的防范措施
- 积累了大量实际开发经验

### 9.2 项目不足

#### 9.2.1 功能方面

- **测试用例管理**：缺少测试用例批量导入功能
- **竞赛功能**：未实现在线竞赛和排名系统
- **代码对比**：缺少代码查重和抄袭检测
- **题解系统**：未实现题解发布和推荐功能

#### 9.2.2 性能方面

- **数据库分库分表**：单表数据量大时性能下降
- **消息队列**：未使用MQ进行解耦
- **负载均衡**：未实现多实例负载均衡
- **监控告警**：缺少系统监控和告警机制

#### 9.2.3 安全方面

- **防刷机制**：缺少接口限流和防刷策略
- **敏感信息**：日志中可能包含敏感信息
- **XSS防护**：前端输入未做充分过滤

### 9.3 后续优化方向

#### 9.3.1 功能扩展

**短期计划**（1-3个月）：
- [ ] 实现测试用例批量导入（Excel/CSV）
- [ ] 添加代码运行记录查看功能
- [ ] 实现题目收藏和推荐功能
- [ ] 优化博客编辑器（图片上传、代码高亮）

**中期计划**（3-6个月）：
- [ ] 实现在线竞赛系统
- [ ] 添加实时排行榜
- [ ] 实现代码查重功能
- [ ] 添加题解系统

**长期计划**（6-12个月）：
- [ ] 支持更多编程语言（Python、Java、Go）
- [ ] 实现分布式判题系统
- [ ] 添加算法可视化功能
- [ ] 实现AI辅助学习功能

#### 9.3.2 性能优化

**数据库优化**：
- [ ] 实现读写分离
- [ ] 热点数据分表
- [ ] 使用ElasticSearch进行全文搜索

**缓存优化**：
- [ ] 实现二级缓存（本地缓存+Redis）
- [ ] 优化缓存失效策略
- [ ] 实现缓存预热

**架构优化**：
- [ ] 引入消息队列（RabbitMQ/Kafka）
- [ ] 实现微服务化改造
- [ ] 实现服务限流和熔断

#### 9.3.3 安全加固

- [ ] 实现接口限流（令牌桶算法）
- [ ] 添加防重放攻击机制
- [ ] 实现敏感信息脱敏
- [ ] 添加SQL注入防护
- [ ] 实现XSS和CSRF防护

#### 9.3.4 运维监控

- [ ] 集成Prometheus+Grafana监控
- [ ] 实现日志收集与分析（ELK）
- [ ] 添加系统告警机制
- [ ] 实现自动化部署（CI/CD）

### 9.4 学习心得

#### 9.4.1 技术学习

1. **理论与实践结合**：
   - 学习框架原理，不仅停留在使用层面
   - 通过实际项目加深对技术的理解
   - 遇到问题主动查阅官方文档

2. **代码质量意识**：
   - 重视代码规范和可读性
   - 添加必要的注释和文档
   - 编写单元测试保证质量

3. **性能优化意识**：
   - 关注系统性能指标
   - 合理使用缓存和索引
   - 避免过度设计

#### 9.4.2 项目管理

1. **需求驱动开发**：
   - 先明确需求再编码
   - 避免需求蔓延
   - 迭代式开发

2. **文档先行**：
   - 编写详细的设计文档
   - 保持文档与代码同步
   - 使用ER图、类图等工具

3. **持续学习**：
   - 关注技术发展趋势
   - 学习优秀开源项目
   - 总结经验教训

#### 9.4.3 未来规划

1. **技术深度**：
   - 深入学习Spring源码
   - 研究分布式系统设计
   - 掌握高并发处理技术

2. **技术广度**：
   - 学习云原生技术（Docker、Kubernetes）
   - 了解大数据处理技术
   - 探索AI/ML在OJ系统中的应用

3. **工程能力**：
   - 提升系统架构设计能力
   - 学习DevOps实践
   - 培养团队协作能力

---

## 10. 附录

### 10.1 核心技术文档链接

| 技术 | 官方文档 |
|------|---------|
| Spring Boot | https://spring.io/projects/spring-boot |
| Spring Security | https://spring.io/projects/spring-security |
| MyBatis-Plus | https://baomidou.com/ |
| Redis | https://redis.io/documentation |
| go-judge | https://github.com/criyle/go-judge |
| Vue 3 | https://vuejs.org/ |

### 10.2 项目统计数据

| 统计项 | 数量 |
|--------|------|
| 代码总行数 | ~15,000行 |
| 数据表数量 | 17个 |
| API接口数量 | ~80个 |
| 模块数量 | 4个核心模块 |
| 开发周期 | ~3个月 |

### 10.3 数据库ER图

**核心实体关系**：

```
用户(User) ─────┐
               │
               ├─N:M─→ 角色(Role) ─N:M─→ 权限(Permission)
               │
               ├─1:N──→ 博客(Blog) ─N:M─→ 标签(Tag)
               │             │
               │             ├─1:N──→ 评论(Comment)
               │             │
               │             └─N:M──→ 收藏(Star)
               │
               └─1:N──→ 提交记录(Submission)
                              │
                              ├─N:1──→ 题目(Problem) ─1:N─→ 测试用例(TestCase)
                              │
                              └─1:N──→ 判题结果(SubmissionResult)
```

### 10.4 系统配置清单

**application.yaml核心配置**：

```yaml
server:
  port: 8080

spring:
  application:
    name: EmiyaOJ
  
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/emiya_oj?serverTimezone=Asia/Shanghai
    username: root
    password: ${DB_PASSWORD}
  
  data:
    redis:
      host: localhost
      port: 6379
      database: 0
      timeout: 3000ms

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  
  global-config:
    db-config:
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0

jwt:
  secret-key: ${JWT_SECRET}
  ttl: 7200000
  token-name: Authorization
```

---

## 结语

EmiyaOJ在线判题系统是一次完整的全栈项目实践，从需求分析、系统设计到编码实现、测试部署，经历了完整的软件开发生命周期。项目成功实现了代码自动判题、用户权限管理、博客社区等核心功能，并在安全性、性能、可扩展性等方面进行了深入思考和实践。

通过本项目，我不仅掌握了Spring Boot、Spring Security、MyBatis-Plus等主流技术栈，还深入理解了RBAC权限模型、JWT无状态认证、Redis缓存设计等重要概念。同时，在解决实际问题的过程中，积累了宝贵的工程经验和问题排查能力。

当然，项目还存在诸多不足之处，如缺少分布式支持、监控告警机制不完善等。在未来的学习和工作中，我将继续优化和完善系统，不断提升自己的技术水平和工程能力。

感谢这次宝贵的学习和实践机会！

---

**文档编写日期**：2026年1月7日  
**项目GitHub地址**：https://github.com/xiaohuanemiya/EmiyaOJ  
**文档版本**：V1.0
